# h248.cnf
# H.248 conformation file

# $Id: h248.cnf 31597 2010-01-21 06:39:25Z etxrab $

#.MODULE_IMPORT

#.EXPORTS

#.PDU

#.NO_EMIT
MtpAddress
PkgdName
ErrorCode
PropertyID
SignalName
SigParameterName
SigParamValue
EventName
EventParameterName
EventParamValue
ContextID

#.TYPE_RENAME
IndAudMediaDescriptor/streams			IndAudMediaDescriptorStreams
ActionRequest/contextId					ContextId
ActionReply/contextId					ContextId
StatisticsParameter/statName			StatName
StatisticsParameter/statValue			StatValue
PropertyParm/propertyName				PropertyName
EventParameter/extraInfo				EventPar_extraInfo
PropertyParm/extraInfo					PropParm_extraInfo
ContextRequest/iepscallind				Iepscallind_BOOL

#.FIELD_RENAME
IP4Address/address		iP4Address
IP6Address/address		iP6Address
ContextAttrAuditRequest/emergency	cAAREmergency
ContextAttrAuditRequest/priority	cAARPriority
SecondRequestedEvent/eventAction	secondaryEventAction
TerminationStateDescriptor/eventBufferControl	tSEventBufferControl
SecondEventsDescriptor/eventList	secondaryEventList
IndAudEventBufferDescriptor/eventName	iAEBDEventName
TerminationID/id			terminationId
IndAudStreamParms/localControlDescriptor iASPLocalControlDescriptor
IndAudStreamParms/localDescriptor	iASPLocalDescriptor
MediaDescriptor/streams/oneStream	mediaDescriptorOneStream
MediaDescriptor/streams/multiStream	mediaDescriptorMultiStream
MediaDescriptor/streams/multiStream/_item	mediaDescriptorMultiStream_item
DomainName/name				domName
IndAudEventsDescriptor/pkgdName		iAEDPkgdName
IndAudLocalRemoteDescriptor/propGrps	iAPropertyGroup
IndAudLocalControlDescriptor/propertyParms	indAudPropertyParms
IndAudTerminationStateDescriptor/propertyParms	indAudPropertyParms
IndAudLocalControlDescriptor/reserveGroup	iALCDReserveGroup
IndAudLocalControlDescriptor/reserveValue	iALCDReserveValue
IndAudLocalControlDescriptor/streamMode		iALCDStreamMode
IndAudStreamDescriptor/streamParms		indAudStreamParms
IndAudMediaDescriptor/termStateDescr		indAudTerminationStateDescriptor
IndAudSignal/signalName				iASignalName
IndAudSeqSigList/signalList			iASignalList
IndAudSignalsDescriptor/signal			indAudSignal
IndAudSignalsDescriptor/seqSigList		indAudSeqSigList
IndAudTerminationStateDescriptor/serviceState   iATSDServiceState
IndAudStreamParms/remoteDescriptor		iASPRemoteDescriptor
PropertyParm/value				propertyParamValue
IndAudMediaDescriptor/streams			indAudMediaDescriptorStreams
AmmRequest/terminationID			terminationIDList
AmmsReply/terminationID			terminationIDList
SubtractRequest/terminationID			terminationIDList
NotifyRequest/terminationID			terminationIDList
NotifyReply/terminationID			terminationIDList
ServiceChangeRequest/terminationID			terminationIDList
ServiceChangeReply/terminationID			terminationIDList
IndAudStatisticsDescriptor/statName		iAStatName
EventParameter/extraInfo				eventPar_extraInfo
PropertyParm/extraInfo					propParm_extraInfo
ContextRequest/iepscallind				iepscallind_BOOL
TransactionRequest/transactionId	transactionId
SegmentReply/transactionId			seg_rep_transactionId
TransactionReply/transactionId		trep_transactionId
TransactionPending/transactionId	tpend_transactionId

#.FN_HDR Message
    curr_info.msg = gcp_msg(actx->pinfo,TVB_RAW_OFFSET(tvb),keep_persistent_data);
#.END

#.FN_FTR Message
    col_add_str(actx->pinfo->cinfo, COL_INFO, gcp_msg_to_str(curr_info.msg,keep_persistent_data));
        
    if (keep_persistent_data)
        gcp_analyze_msg(h248_tree, h248_tvb, curr_info.msg, &h248_arrel);
#.END

#.FN_BODY Message/version VAL_PTR = &h248_version 
	%(DEFAULT_BODY)s
#.END

#.FN_BODY TransactionRequest/transactionId
    guint32 trx_id = 0;
	offset = dissect_h248_trx_id(implicit_tag, actx->pinfo, tree, tvb, offset, &trx_id);
    curr_info.trx = gcp_trx(curr_info.msg, trx_id, GCP_TRX_REQUEST, keep_persistent_data);
    error_code = 0;
#.END

#.FN_BODY TransactionPending/transactionId
    guint32 trx_id = 0;
	offset = dissect_h248_trx_id(implicit_tag, actx->pinfo, tree, tvb, offset, &trx_id);
    curr_info.trx = gcp_trx(curr_info.msg, trx_id, GCP_TRX_PENDING, keep_persistent_data);
    error_code = 0;

#.FN_BODY TransactionReply/transactionId		
    guint32 trx_id = 0;
	offset = dissect_h248_trx_id(implicit_tag, actx->pinfo, tree, tvb, offset, &trx_id);
    curr_info.trx = gcp_trx(curr_info.msg, trx_id, GCP_TRX_REPLY, keep_persistent_data);
    error_code = 0;

#.FN_BODY SegmentReply/transactionId
    guint32 trx_id = 0;
	offset = dissect_h248_trx_id(implicit_tag, actx->pinfo, tree, tvb, offset, &trx_id);
    curr_info.trx = gcp_trx(curr_info.msg, trx_id, GCP_TRX_ACK, keep_persistent_data);
    error_code = 0;

#.FN_BODY ActionRequest/contextId
    guint32 ctx_id = 0;
	offset = dissect_h248_ctx_id(implicit_tag, actx->pinfo, tree, tvb, offset, &ctx_id);
    curr_info.ctx = gcp_ctx(curr_info.msg,curr_info.trx,ctx_id,keep_persistent_data);
    curr_info.cmd = NULL;
    curr_info.term = NULL;
#.END


#.FN_FTR ActionReply
    if (!curr_info.cmd) {
	  curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_REPLY,offset,keep_persistent_data);
      H248_TAP();
	}
#.END

#.FN_HDR Command/addReq
	  curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_ADD_REQ,offset,keep_persistent_data);
      H248_TAP();
#.END

#.FN_FTR Command/addReq
      curr_info.cmd = NULL;
#.END

#.FN_HDR Command/moveReq
	  curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_MOVE_REQ,offset,keep_persistent_data);
      H248_TAP();

#.END

#.FN_FTR Command/moveReq
      curr_info.cmd = NULL;
#.END

#.FN_HDR Command/modReq
	  curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_MOD_REQ,offset,keep_persistent_data);
      H248_TAP();
#.END
#.FN_FTR Command/modReq
      curr_info.cmd = NULL;
#.END

#.FN_HDR Command/subtractReq
	  curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_SUB_REQ,offset,keep_persistent_data);
      H248_TAP();
#.END
#.FN_FTR Command/subtractReq
      curr_info.cmd = NULL;
#.END

#.FN_HDR Command/auditCapRequest
	  curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_AUDITCAP_REQ,offset,keep_persistent_data);
      H248_TAP();
#.END
#.FN_FTR Command/auditCapRequest
      curr_info.cmd = NULL;
#.END

#.FN_HDR Command/auditValueRequest
	  curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_AUDITVAL_REQ,offset,keep_persistent_data);
      H248_TAP();
#.END
#.FN_FTR Command/auditValueRequest
      curr_info.cmd = NULL;
#.END

#.FN_HDR Command/notifyReq
	  curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_NOTIFY_REQ,offset,keep_persistent_data);
      H248_TAP();
#.END
#.FN_FTR Command/notifyReq
      curr_info.cmd = NULL;
#.END

#.FN_HDR ServiceChangeRequest
      curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_SVCCHG_REQ,offset,keep_persistent_data);
      H248_TAP();
#.END
#.FN_FTR ServiceChangeRequest
      curr_info.cmd = NULL;
#.END

#.FN_HDR ContextRequest/topologyReq
      curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_TOPOLOGY_REQ,offset,keep_persistent_data);
      H248_TAP();
#.END
#.FN_FTR ContextRequest/topologyReq
      curr_info.cmd = NULL;
#.END

#.FN_HDR ActionRequest/contextAttrAuditReq
      curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_CTX_ATTR_AUDIT_REQ,offset,keep_persistent_data);
      H248_TAP();
#.END
#.FN_FTR ActionRequest/contextAttrAuditReq
      curr_info.cmd = NULL;
#.END

#.FN_HDR CommandReply/addReply
      curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_ADD_REPLY,offset,keep_persistent_data);
      H248_TAP();
#.END

#.FN_HDR CommandReply/moveReply
      curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_MOVE_REPLY,offset,keep_persistent_data);
      H248_TAP();
#.END

#.FN_HDR CommandReply/modReply
      curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_MOD_REPLY,offset,keep_persistent_data);
      H248_TAP();
#.END

#.FN_HDR CommandReply/subtractReply
      curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_SUB_REPLY,offset,keep_persistent_data);
      H248_TAP();
#.END

#.FN_HDR CommandReply/notifyReply
      curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_NOTIFY_REPLY,offset,keep_persistent_data);
      H248_TAP();
#.END

#.FN_HDR ServiceChangeReply
      curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_SVCCHG_REPLY,offset,keep_persistent_data);
      H248_TAP();
#.END

#.FN_HDR CommandReply/auditCapReply
      curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_AUDITCAP_REPLY,offset,keep_persistent_data);
      H248_TAP();
#.END

#.FN_BODY CommandReply/auditCapReply
/* h248v1 support */
	if(h248_version > 1) {
		%(DEFAULT_BODY)s
} else {
		/* call V1 of the dissector */
		offset = dissect_h248_AuditReplyV1(implicit_tag, tvb, offset, actx, tree, hf_index);
}
#.END

#.FN_HDR CommandReply/auditValueReply
      curr_info.cmd = gcp_cmd(curr_info.msg,curr_info.trx,curr_info.ctx,GCP_CMD_AUDITVAL_REPLY,offset,keep_persistent_data);
      H248_TAP();
#.END

#.FN_BODY CommandReply/auditValueReply
/* h248v1 support */
	if(h248_version > 1) {
		%(DEFAULT_BODY)s
} else {
		/* call V1 of the dissector */
		offset = dissect_h248_AuditReplyV1(implicit_tag, tvb, offset, actx, tree, hf_index);
}
#.END

#.FN_BODY AuditReplyV1
/* h248v1 support */
	offset = dissect_ber_sequence(implicit_tag, actx, tree, tvb, offset,
		AuditReplyV1_sequence, hf_h248_auditValueReplyV1, ett_h248_AuditReplyV1);
#.END

#.FN_BODY ErrorDescriptor/errorCode
    offset = dissect_ber_integer(implicit_tag, actx, tree, tvb, offset, hf_h248_error_code, &error_code);
    expert_add_info_format(actx->pinfo, actx->created_item, PI_RESPONSE_CODE, PI_WARN, "Errored Command");
    
    if (curr_info.cmd) {
        gcp_cmd_set_error(curr_info.cmd,error_code);
    } else if (curr_info.trx) {
        gcp_trx_set_error(curr_info.trx,error_code);
    }
    
    return offset;
#.END

#.FN_HDR TerminationID
    curr_info.term = ep_new0(gcp_term_t);
    wild_term = GCP_WILDCARD_NONE;
#.END

#.FN_BODY WildcardField
    tvbuff_t* new_tvb;
    offset = dissect_ber_octet_string(implicit_tag, actx, tree, tvb, offset, hf_index, &new_tvb);
    tree = proto_item_add_subtree(actx->created_item,ett_wildcard);
    proto_tree_add_item(tree,hf_h248_term_wild_type,new_tvb,0,1,FALSE);
    proto_tree_add_item(tree,hf_h248_term_wild_level,new_tvb,0,1,FALSE);
    proto_tree_add_item(tree,hf_h248_term_wild_position,new_tvb,0,1,FALSE);

    wild_term = tvb_get_guint8(new_tvb,0) & 0x80 ? GCP_WILDCARD_CHOOSE : GCP_WILDCARD_ALL;
    /* limitation: assume only one wildcard is used */
    wild_card = tvb_get_guint8(new_tvb,0);
    
#.END

#.FN_BODY TerminationID/id
	tvbuff_t* new_tvb;
	offset = dissect_ber_octet_string(implicit_tag, actx, tree, tvb, offset, hf_index, &new_tvb);
	
	if (new_tvb) {
		curr_info.term->len = tvb_length(new_tvb);
		curr_info.term->type = 0; /* unknown */

		if (curr_info.term->len) {
			curr_info.term->buffer = ep_tvb_memdup(new_tvb,0,curr_info.term->len);
			curr_info.term->str = bytes_to_str(curr_info.term->buffer,curr_info.term->len);
		}

		curr_info.term = gcp_cmd_add_term(curr_info.msg, curr_info.trx, curr_info.cmd, curr_info.term, wild_term, keep_persistent_data);

		if (h248_term_handle) {
		    actx->pinfo->private_data = &wild_card;		    
			call_dissector(h248_term_handle, new_tvb, actx->pinfo, tree);
			wild_card = 0xFF;		
		}
	} else {
		curr_info.term->len = 0;
		curr_info.term->buffer = (guint8*)ep_strdup("");
		curr_info.term->str = ep_strdup("?");
	}
#.END

#.FN_BODY SCreasonValue
/* H248 v1 support */
	if ( h248_version >1 ) {	
		/* Not V1, so call "standard" function */
%(DEFAULT_BODY)s	
} else {
			/* V1 so Value == octet string */
		offset = dissect_h248_ValueV1( implicit_tag, tvb, offset, actx, tree, hf_index);
};
	
#.END

#.FN_BODY SCreasonValueOctetStr VAL_PTR = &parameter_tvb

 tvbuff_t	*parameter_tvb;
 %(DEFAULT_BODY)s

 if (!parameter_tvb)
	return offset;

 dissect_h248_ServiceChangeReasonStr(FALSE, parameter_tvb, 0, actx, tree, hf_h248_serviceChangeReasonStr);
#.END

#.FN_HDR ValueV1
	guint8 i;
	guint32 len;
#.END

#.FN_BODY ValueV1
/* check tvb to verify all values ascii or not.  If so, output string, else hex */
	len=tvb_length_remaining(tvb, offset);
	for( i=0;i<len;i++) {
		if(!isascii(tvb_get_guint8(tvb, offset+i)) || tvb_get_guint8(tvb, offset+i) == 0) {
			/* not ascii or NULL character so do string as hex string */
			proto_tree_add_text(tree, tvb, offset, len,"%s: 0x%s", 
				(proto_registrar_get_nth(hf_index))->name,
				tvb_bytes_to_str(tvb, 0, len));
			return len;
		};
	};
	/* if here, then string is ascii */
	proto_tree_add_text(tree, tvb, offset, len,"%s: %s", 
				(proto_registrar_get_nth(hf_index))->name,
				tvb_format_text(tvb, 0, len));
	offset = len;
#.END

#.FN_BODY EventParameter
/* H248 v1 support */
	if (h248_version >1) {
		%(DEFAULT_BODY)s
} else {
		offset = dissect_h248_EventParameterV1( implicit_tag, tvb, offset, actx, tree, hf_index);
}
#.END

#.FN_BODY SigParameter
/* H248 v1 support */
	if (h248_version >1) {
		%(DEFAULT_BODY)s
} else {
		offset = dissect_h248_SigParameterV1( implicit_tag, tvb, offset, actx, tree, hf_index);
}
#.END


#.FN_BODY PropertyParm
/* H248 v1 support */
	if (h248_version >1) {
		%(DEFAULT_BODY)s
} else {
		offset = dissect_h248_PropertyParmV1( implicit_tag, tvb, offset, actx, tree, hf_index);
}
#.END

#.TYPE_ATTR
IP4Address/address  TYPE = FT_IPv4  DISPLAY = BASE_NONE  STRINGS = NULL
IP6Address/address  TYPE = FT_IPv6  DISPLAY = BASE_NONE  STRINGS = NULL
ActionRequest/contextId TYPE = FT_UINT32 DISPLAY = BASE_HEX STRINGS = NULL
ActionReply/contextId TYPE = FT_UINT32 DISPLAY = BASE_HEX STRINGS = NULL
